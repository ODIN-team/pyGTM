
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>GTMcore module &#8212; pyGTM 2.0.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Material database module" href="Permittivities.html" />
    <link rel="prev" title="Welcome to pyGTM’s documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyGTM</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">GTMcore module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-layer-class">The Layer class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-system-class">The System class</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Permittivities.html">Material database module</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to pyGTM’s documentation</a></li>
      <li>Next: <a href="Permittivities.html" title="next chapter">Material database module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-GTM.GTMcore">
<span id="gtmcore-module"></span><span id="gtmcore-label"></span><h1>GTMcore module<a class="headerlink" href="#module-GTM.GTMcore" title="Permalink to this headline">¶</a></h1>
<p>This program implements the generalized 4x4 transfer matrix (GTM) method 
poposed in <a class="reference external" href="http://doi.org/10.1364/JOSAB.34.002128">Passler, N. C. and Paarmann, A., JOSA B 34, 2128 (2017)</a>
and corrected in 
<a class="reference external" href="http://doi.org/10.1364/JOSAB.36.003246">JOSA B 36, 3246 (2019)</a>, 
as well as the layer-resolved absorption proposed in 
<a class="reference external" href="https://arxiv.org/abs/2002.03832">Passler, Jeannin and Paarman</a>. 
This code uses inputs from D. Dietze’s FSRStools library
<a class="reference external" href="https://github.com/ddietze/FSRStools">https://github.com/ddietze/FSRStools</a></p>
<p>Please cite the relevant associated publications if you use this code.</p>
<dl class="simple">
<dt>Author: </dt><dd><ul class="simple">
<li><p>Mathieu Jeannin <a class="reference external" href="mailto:math&#46;jeannin&#37;&#52;&#48;free&#46;fr">math<span>&#46;</span>jeannin<span>&#64;</span>free<span>&#46;</span>fr</a> (permanent)</p></li>
</ul>
</dd>
<dt>Affiliations: </dt><dd><ul class="simple">
<li><p>Laboratoire de Physique de l’Ecole Normale Superieure (2019)</p></li>
<li><p>Centre de Nanosciences et Nanotechnologies (2020)</p></li>
</ul>
</dd>
</dl>
<p>Layers are represented by the <a class="reference internal" href="#GTM.GTMcore.Layer" title="GTM.GTMcore.Layer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></a> class that holds all parameters 
describing the optical properties of a single layer. 
The optical system is assembled using the <a class="reference internal" href="#GTM.GTMcore.System" title="GTM.GTMcore.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> class.</p>
<p><strong>Change log:</strong></p>
<blockquote>
<div><p><em>19-03-2020</em>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Adapted the code to compute the layer-resolved absorption as proposed 
by Passler et al. (<a class="reference external" href="https://arxiv.org/abs/2002.03832">https://arxiv.org/abs/2002.03832</a>), using 
<a class="reference internal" href="#GTM.GTMcore.System.calculate_Poynting_Absorption_vs_z" title="GTM.GTMcore.System.calculate_Poynting_Absorption_vs_z"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.calculate_Poynting_Absorption_vs_z()</span></code></a>.</p></li>
<li><p>Include the correct calculation of intensity transmission coefficients 
in <a class="reference internal" href="#GTM.GTMcore.System.calculate_r_t" title="GTM.GTMcore.System.calculate_r_t"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.calculate_r_t()</span></code></a>. 
<strong>This BREAKS compatibility</strong> with the previous definition of the function.</p></li>
<li><p>Corrected bugs in <a class="reference internal" href="#GTM.GTMcore.System.calculate_Efield" title="GTM.GTMcore.System.calculate_Efield"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.calculate_Efield()</span></code></a> 
and added magnetic field option</p></li>
<li><p>Adapted <a class="reference internal" href="#GTM.GTMcore.System.calculate_Efield" title="GTM.GTMcore.System.calculate_Efield"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.calculate_Efield()</span></code></a> to allow hand-defined, 
irregular grid and a shorthand to compute only at layers interfaces. 
Regular grid with fixed resolution is left as an option.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt><em>20-09-2019</em>:</dt><dd><ul class="simple">
<li><p>Added functions in the <a class="reference internal" href="#GTM.GTMcore.System" title="GTM.GTMcore.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> class to compute in-plane 
wavevector of guided modes and dispersion relation for such guided surface modes.
This is <em>highly prospective</em> as it depends on the robustness of the minimization 
procedure (or the lack of thereoff)</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>The main algorithm is based on solving the eigenvalue equation for the electric field in each layer. The results are then propagated in a step-wised manner layer by layer accross the entire stack.</p>
<img alt="_images/Layers_Field_Buildup.png" src="_images/Layers_Field_Buildup.png" />
<div class="section" id="the-layer-class">
<h2>The Layer class<a class="headerlink" href="#the-layer-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="GTM.GTMcore.Layer">
<em class="property">class </em><code class="sig-prename descclassname">GTM.GTMcore.</code><code class="sig-name descname">Layer</code><span class="sig-paren">(</span><em class="sig-param">thickness=1e-06</em>, <em class="sig-param">epsilon1=None</em>, <em class="sig-param">epsilon2=None</em>, <em class="sig-param">epsilon3=None</em>, <em class="sig-param">theta=0</em>, <em class="sig-param">phi=0</em>, <em class="sig-param">psi=0</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer class. An instance is a single layer:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>thickness</strong> (<em>float</em>) – thickness of the layer in m</p></li>
<li><p><strong>epsilon1</strong> (<em>function</em>) – function epsilon(frequency) for the first axis. If none, defaults to vacuum.</p></li>
<li><p><strong>epsilon2</strong> (<em>function</em>) – function epsilon(frequency) for the second axis. If none, defaults to epsilon1.</p></li>
<li><p><strong>epsilon3</strong> (<em>function</em>) – function epsilon(frequency) for the third axis. If none, defaults to epsilon1.</p></li>
<li><p><strong>theta</strong> (<em>float</em>) – Euler angle theta (colatitude)</p></li>
<li><p><strong>phi</strong> (<em>float</em>) – Euler angle phi</p></li>
<li><p><strong>psi</strong> (<em>float</em>) – Euler angle psi</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="GTM.GTMcore.Layer.calculate_epsilon">
<code class="sig-name descname">calculate_epsilon</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.calculate_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of epsilon in the (rotated) lab frame.</p>
<p>The values are set according to the epsilon_fi (i=1..3) functions 
defined using the ‘set_epsilon’ method, at the given frequency f. 
The rotation w/ respect to the lab frame is computed using the Euler angles.</p>
<p>** Use only explicitely if you don’t use the <cite>update</cite> function **</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.calculate_gamma">
<code class="sig-name descname">calculate_gamma</code><span class="sig-paren">(</span><em class="sig-param">zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.calculate_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the gamma matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>zeta</strong> (<em>complex</em>) – in-plane reduced wavevector kx/k0</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.calculate_matrices">
<code class="sig-name descname">calculate_matrices</code><span class="sig-paren">(</span><em class="sig-param">zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.calculate_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the principal matrices necessary for the GTM algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>zeta</strong> (<em>complex128</em>) – in-place reduced wavevector kx/k0 in the system.</p>
</dd>
</dl>
<p>Note that zeta is conserved through the whole system and set externaly
using the angle of incidence and System.superstrate.epsilon[0,0] value</p>
<p>** Requires prior execution of <cite>calculate_epsilon</cite> **</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.calculate_q">
<code class="sig-name descname">calculate_q</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.calculate_q" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calculates the 4 out-of-plane wavevectors for the current layer.</p>
<p>From this we also get the Poynting vectors. 
Wavevectors are sorted according to (trans-p, trans-s, refl-p, refl-s)
Birefringence is determined according to a threshold value <cite>qsd_thr</cite> 
set at the beginning of the script.</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.calculate_transfer_matrix">
<code class="sig-name descname">calculate_transfer_matrix</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.calculate_transfer_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the transfer matrix of the whole layer T=APA^{-1}</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>float</em>) – frequency</p></li>
<li><p><strong>zeta</strong> (<em>complex</em>) – reduced in-plane wavevector kx/k0</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.set_epsilon">
<code class="sig-name descname">set_epsilon</code><span class="sig-paren">(</span><em class="sig-param">epsilon1=None</em>, <em class="sig-param">epsilon2=None</em>, <em class="sig-param">epsilon3=None</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.set_epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the dielectric functions for the three main axis.</p>
<p>Each epsilon_i function returns the dielectric constant along axis i as 
a function of the frequency f in Hz.</p>
<p>epsilon1 defaults to 1.0
epsilon2 and epsilon3 default to epsilon1: if None, a homogeneous material is assumed</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.set_euler">
<code class="sig-name descname">set_euler</code><span class="sig-paren">(</span><em class="sig-param">theta</em>, <em class="sig-param">phi</em>, <em class="sig-param">psi</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.set_euler" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the values for the Euler rotations angles. 
:param float theta: Euler angle theta (colatitude)
:param float phi: Euler angle phi
:param float psi: Euler angle psi</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.set_thickness">
<code class="sig-name descname">set_thickness</code><span class="sig-paren">(</span><em class="sig-param">thickness</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.set_thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the layer thickness</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.Layer.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.Layer.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut to recalculate all layer properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta</strong> (<em>float</em>) – in-plane propagation vector (reduced)</p></li>
<li><p><strong>f</strong> (<em>float</em>) – Frequency value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrices Ai, Ki, Ai^{-1} and Ti</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-system-class">
<h2>The System class<a class="headerlink" href="#the-system-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="GTM.GTMcore.System">
<em class="property">class </em><code class="sig-prename descclassname">GTM.GTMcore.</code><code class="sig-name descname">System</code><span class="sig-paren">(</span><em class="sig-param">substrate=None</em>, <em class="sig-param">superstrate=None</em>, <em class="sig-param">layers=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System" title="Permalink to this definition">¶</a></dt>
<dd><p>System class. An instance is an optical system with substrate, superstrate and layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> (<em>float</em>) – angle of incidence, in radians</p></li>
<li><p><strong>substrate</strong> (<em>layer</em>) – the substrate layer. defaults to vacuum (empty layer instance)</p></li>
<li><p><strong>superstrate</strong> (<em>layer</em>) – the superstrate layer, defaults to vacuum (empty layer instance)</p></li>
<li><p><strong>layers</strong> (<em>list</em>) – list of the layers</p></li>
</ul>
</dd>
</dl>
<p>Layers can be added and removed (not inserted).</p>
<p>The whole system’s transfer matrix is computed using calculate_GammaStar, 
which calls layer.update() for each layer.
General reflection and transmission coeffs. functions are given, they require prior 
execution of calculate_GammaStar.
The electric fields can be visualized in the case of incident plane wave
using calculate_Efield</p>
<dl class="method">
<dt id="GTM.GTMcore.System.add_layer">
<code class="sig-name descname">add_layer</code><span class="sig-paren">(</span><em class="sig-param">layer</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.add_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a layer instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>layer</strong> (<em>layer</em>) – the layer to be added on the stack</p>
</dd>
</dl>
<p>Note that the layers are added <strong>from superstrate to substrate</strong> order.
Light is incident from the superstrate.</p>
<p>Note thate this function adds a reference to L to the list. 
If you are adding the same layer several times, be aware that if you 
change something for one of them, it changes all of them.</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_Efield">
<code class="sig-name descname">calculate_Efield</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">zeta_sys</em>, <em class="sig-param">z_vect=None</em>, <em class="sig-param">x=0.0</em>, <em class="sig-param">magnetic=False</em>, <em class="sig-param">dz=None</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_Efield" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the electric field profiles for both s-pol and p-pol excitation.</p>
<dl class="simple">
<dt>..Version 19-03-2020:</dt><dd><p>changed keywords to add z_vect
z_vect is used for either minimal computation (using get_layers_boundaries)
or hand-defined z-positions (e.g. irregular spacing for improved resolution)
if dz is given, a regular grid is used.
A sketch of the definition of all fields and algorithm is supplied in the module,
to better get a grasp on where Fft and Fbk are defined.</p>
</dd>
<dt>..Version 28-01-2020:</dt><dd><p>Added Magnetic field keyword to save time.
Poyting and absorption defined in a separate function</p>
</dd>
<dt>..Version 06-01-2020:</dt><dd><p>Added Magnetic field and Poyting vector.</p>
</dd>
<dt>..Version 13-09-2019:</dt><dd><p>the 2D field profile is not implemented yet. x should be left to default</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>float</em>) – frequency (Hz)</p></li>
<li><p><strong>zeta_sys</strong> (<em>complex</em>) – in-plane normalized wavevector kx/k0</p></li>
<li><p><strong>z_vect</strong> (<em>float</em>) – coordinates at which the calculation is done. if None, the layers boundaries are used.</p></li>
<li><p><strong>x</strong> (<em>array</em>) – x-coordinates for (future) 2D plot of the electric field.</p></li>
<li><p><strong>magnetic</strong> (<em>bool</em>) – boolean to skip or compute the magnetic field vector</p></li>
<li><p><strong>dz</strong> (<em>float</em>) – space resolution along propagation (z) axis. Superseed z_vect</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1D array of z-coordinates according to dz</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>(len(z),3)-Array E_out of total electric field in the structure</p>
</dd>
<dt class="field-even">Return (opt)</dt>
<dd class="field-even"><p>(len(z),3)-Array H_out of total magnetic field in the structure</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list zn of the positions of the different interfaces</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_GammaStar">
<code class="sig-name descname">calculate_GammaStar</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">zeta_sys</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_GammaStar" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the whole system’s transfer matrix GammaStar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>float</em>) – frequency (Hz)</p></li>
<li><p><strong>zeta_sys</strong> (<em>complex</em>) – in-plane wavevector kx/k0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>System transfer matrix np.array((4,4), dtype=np.complex128)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_Poynting_Absorption_vs_z">
<code class="sig-name descname">calculate_Poynting_Absorption_vs_z</code><span class="sig-paren">(</span><em class="sig-param">z</em>, <em class="sig-param">E</em>, <em class="sig-param">H</em>, <em class="sig-param">R</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_Poynting_Absorption_vs_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the z-dependent Poynting vector and cumulated absorption.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z</strong> (<em>array</em>) – spatial coordinate for the fields</p></li>
<li><p><strong>E</strong> (<em>array</em>) – 6-components Electric field vector (p- or s- in) along z</p></li>
<li><p><strong>H</strong> (<em>array</em>) – 6-components Magnetic field vector (p- or s- in) along z</p></li>
<li><p><strong>R</strong> (<em>array</em>) – Reflectivity from calculate_r_t()</p></li>
</ul>
</dd>
<dt class="field-even">Return array S_out</dt>
<dd class="field-even"><p>6 components (p//s) Poyting vector along z</p>
</dd>
<dt class="field-odd">Return array A_out</dt>
<dd class="field-odd"><p>2 components (p//s) absorption along z</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_eigen_wv">
<code class="sig-name descname">calculate_eigen_wv</code><span class="sig-paren">(</span><em class="sig-param">zeta0</em>, <em class="sig-param">f</em>, <em class="sig-param">bounds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_eigen_wv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the eigenmode in-plane wavevector that shows guiding along the plane.
Based on the idea that guided mode := an output field exists with no input field
This is <strong>strongly</strong> dependant on the minimization procedure and thus 
has to be consistently and carefully checked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta0</strong> (<em>2-tuple</em>) – initial guess for the minimization procedure</p></li>
<li><p><strong>f</strong> (<em>float</em>) – frequency</p></li>
<li><p><strong>bounds</strong><strong> (</strong><strong>optional</strong><strong>)</strong> (<em>list</em>) – list of 2-tuple containing (lower, upper) bound for each parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result of the minimization procedure. Eigenvalue is the list res.x</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_matelem">
<code class="sig-name descname">calculate_matelem</code><span class="sig-paren">(</span><em class="sig-param">zeta0</em>, <em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_matelem" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the relevant quantity to find waveguide modes according 
to Davis’ paper on multilayers (scalar model 
<a class="reference external" href="http://doi.org/10.1016/j.optcom.2008.09.043">http://doi.org/10.1016/j.optcom.2008.09.043</a>)
and then Yeh (4X4 formalism <a class="reference external" href="http://doi.org/10.1016/0039-6028(80)90293-9">http://doi.org/10.1016/0039-6028(80)90293-9</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zeta0</strong> (<em>2-tuple</em>) – Tuple [zeta_r, zeta_i] of real and imaginary part of the wavevector</p></li>
<li><p><strong>f</strong> (<em>float</em>) – frequency</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>matrix element to minimize for dispersion relation (absolute value)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.calculate_r_t">
<code class="sig-name descname">calculate_r_t</code><span class="sig-paren">(</span><em class="sig-param">zeta_sys</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.calculate_r_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate various field and intensity reflection and transmission coefficients, as well as the 4-valued vector of transmitted field.</p>
<p><strong>IMPORTANT</strong> 
..version 19-03-2020
All intensity coefficients are now well defined. Transmission is defined 
mode-independently. It could be defined mode-dependently for non-birefringent 
substrates in future versions. 
The new definition of this function <strong>BREAKS compatibility</strong> with the previous 
one.</p>
<p>..version 13-09-2019
Note that the field reflectivity and transmission coefficients 
r and t are well defined. The intensity reflection coefficient is also correct. 
However, the intensity transmission coefficients T are ill-defined so far. 
This will be corrected upon future publication of the correct intensity coefficients.</p>
<p>Note also the different ordering of the coefficients, for consistency w/ Passler’s matlab code</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>zeta_sys</strong> (<em>complex</em>) – incident in-plane wavevector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Complex <em>field</em> reflection coefficients r_out=([rpp,rps,rss,rsp])</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Real <em>intensity</em> reflection coefficients R_out=([Rpp,Rss,Rsp,Tps])</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Complex <em>field</em> transmition coefficients t=([tpp, tps, tsp, tss])</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Real <em>intensity</em> transmition coefficients T_out=([Tp,Ts]) (mode-inselective)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.del_layer">
<code class="sig-name descname">del_layer</code><span class="sig-paren">(</span><em class="sig-param">pos</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.del_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a layer at given position. Does nothing for invalid position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pos</strong> (<em>integer</em>) – index of layer to be removed.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.disp_vs_f">
<code class="sig-name descname">disp_vs_f</code><span class="sig-paren">(</span><em class="sig-param">fv</em>, <em class="sig-param">zeta0</em>, <em class="sig-param">bounds=None</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.disp_vs_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a frequency dependent search of the eigenwavevector for a guided mode
to get the dispersion relation of a surface mode.</p>
<p>Provided a reasonable initial guess for the first frequency point, we 
use the eigen_wv from the above method and follow its value as a function 
of frequency in a stepping manner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fv</strong> (<em>array</em>) – array of frequencies</p></li>
<li><p><strong>zeta0</strong> (<em>2-tuple</em>) – initial guess</p></li>
<li><p><strong>bounds</strong> (<em>list</em>) – list of 2-tuple containing (lower, upper) bound for each parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of real part of the in-plane wavevector</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>array of imagniary part of the in-plane wavevector</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_all_layers">
<code class="sig-name descname">get_all_layers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_all_layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of all layers in the system</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_layer">
<code class="sig-name descname">get_layer</code><span class="sig-paren">(</span><em class="sig-param">pos</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the layer at a given position</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pos</strong> (<em>int</em>) – position in the stack</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the layer at the position <cite>pos</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_layers_boundaries">
<code class="sig-name descname">get_layers_boundaries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_layers_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the z-position of all boundaries, including the “top” of the 
superstrate and the “bottom” of the substrate. This corresponds to where 
the fields should be evaluated to get a minimum of information</p>
<p>“return” : array of layer boundary positions</p>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_spatial_permittivity">
<code class="sig-name descname">get_spatial_permittivity</code><span class="sig-paren">(</span><em class="sig-param">z</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_spatial_permittivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the permittivity tensor at given z in the structure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>z</strong> (<em>array</em>) – array of points to sample the permittivity</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array (3x3xlen(z)) of the permittivity tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_substrate">
<code class="sig-name descname">get_substrate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the System’s substrate</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <cite>System</cite> substrate</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.get_superstrate">
<code class="sig-name descname">get_superstrate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.get_superstrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the System’s superstrate</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <cite>System</cite> superstrate</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.initialize_sys">
<code class="sig-name descname">initialize_sys</code><span class="sig-paren">(</span><em class="sig-param">f</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.initialize_sys" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the values of epsilon at given frequency, allowing to define zeta out of the class</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> (<em>float</em>) – frequency (Hz)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.set_substrate">
<code class="sig-name descname">set_substrate</code><span class="sig-paren">(</span><em class="sig-param">sub</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.set_substrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the substrate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sub</strong> (<em>layer</em>) – instance of the layer class, substrate</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="GTM.GTMcore.System.set_superstrate">
<code class="sig-name descname">set_superstrate</code><span class="sig-paren">(</span><em class="sig-param">sup</em><span class="sig-paren">)</span><a class="headerlink" href="#GTM.GTMcore.System.set_superstrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the superstrate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sup</strong> (<em>layer</em>) – instance of the layer class, superstrate</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2020, Mathieu Jeannin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/GTMcore.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>